#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "machine.h"

#define INT_STRING  "0123456789"

typedef struct {
    char    *buffer;
    size_t  bufferSize;
    size_t  bufPointer;
    int     col, line;
} srcBuffer;


//read file contents into a buffer 
size_t 
utility_fileReader(const char *filename, char **input_buffer) {
    FILE *f = fopen(filename, "rb");
    size_t file_size = 0;

    if (!f) return 0;   // failed to open the file

    fseek(f, 0, SEEK_END);
    file_size = (size_t)ftell(f);
    rewind(f);

    *input_buffer = malloc(file_size + 1);
    if (!*input_buffer) {
        fclose(f);
        return 0;
    }

    fread(*input_buffer, 1, file_size, f);
    (*input_buffer)[file_size] = '\0';  // sentinel
    fclose(f);

    return file_size;
}


//peek the buffer 
static char
peekChar(srcBuffer *b) 
{
    if (!b->buffer || b->bufPointer >= b->bufferSize) return '\0';
    return b->buffer[b->bufPointer];
}

// advance pointer but never pass bufferSize 
static void 
advance(srcBuffer *b) {    if (b->bufPointer < b->bufferSize) b->bufPointer++;}



// skip whitespace and update line count 
void 
skipSpaces(srcBuffer *sb) 
{
    char c = peekChar(sb);
    while (c != '\0' && isspace((unsigned char)c)) {
        if (c == '\n') sb->line++;
        advance(sb);
        c = peekChar(sb);
    }
}

// return index of character in DIGITS or -1
static int 
charToInt(const char *dig, char c) 
{
    char *p = strchr(dig, c);
    return p ? (int)(p - dig) : -1;
}

// read integer (handles optional leading '-')
static int 
readInt(srcBuffer *sb) 
{
    int k, val = 0, neg = 0;
    char c = peekChar(sb);

    if (c == '-') 
    {
        neg = 1;
        advance(sb);
        c = peekChar(sb);
    }

    if (!isdigit((unsigned char)c)) 
    {
        fprintf(stderr, "ASVM: line %d: expected a digit after optional sign\n", sb->line);
        exit(1);
    }

    k = charToInt(INT_STRING, c);
    while (k >= 0) 
    {
        val = val * 10 + k;
        advance(sb);
        c = peekChar(sb);
        k = charToInt(INT_STRING, c);
    }

    return neg ? -val : val;
}

//read mnemonic: returns length and sets *start to pointer inside buffer
int 
readMnemonic(srcBuffer *sb, char **start) 
{
    skipSpaces(sb);
    *start = sb->buffer + sb->bufPointer;
    int size = 0;
    char c = peekChar(sb);

    /* stop at whitespace, comma, or NUL or end-of-buffer */
    while (c != '\0' && !isspace((unsigned char)c) && c != ',' ) {
        size++;
        advance(sb);
        c = peekChar(sb);
    }

    return size;
}



opcode mnemonicToOpcode(const char *mnemonic)
{
   switch(toupper(mnemonic[0]))
   {
    case 'A':
        if(!strcasecmp(mnemonic, "ADD")) return  ADD;
        if(!strcasecmp(mnemonic, "ALLOC")) return  ALLOC;
    case 'B':
        if(!strcasecmp(mnemonic, "BEQ")) return  BEQ;
        if(!strcasecmp(mnemonic, "BGE")) return  BGE;
        if(!strcasecmp(mnemonic, "BGT")) return  BGT;
        if(!strcasecmp(mnemonic, "BLE")) return  BLE;
        if(!strcasecmp(mnemonic, "BLT")) return  BLT;
        if(!strcasecmp(mnemonic, "BNE")) return  BNE;
    case 'D':
        if(!strcasecmp(mnemonic, "DIV")) return  DIV;
    case 'H':
        if(!strcasecmp(mnemonic, "HALT")) return  HALT;
    case 'J':
        if(!strcasecmp(mnemonic, "JUMP")) return  JUMP;
    case 'L':
        if(!strcasecmp(mnemonic, "LDA")) return  LDA;
    case 'M':
        if(!strcasecmp(mnemonic, "MOD")) return  MOD;
        if(!strcasecmp(mnemonic, "MUL")) return  MUL;
    case 'N':
        if(!strcasecmp(mnemonic, "NOT")) return  NOT;
    case 'P':
        if(!strcasecmp(mnemonic, "PRINTI")) return  PRINTI;
        if(!strcasecmp(mnemonic, "PUSH")) return  PUSH;
    case 'S':
        if(!strcasecmp(mnemonic, "SUB")) return  SUB;
    case 'V':
        if(!strcasecmp(mnemonic, "VAL")) return  VAL;
     default: return NO_OPCODE;
   }
}


const char* opcodeToMnemonic(opcode op)
{
   switch(op)
   {
       case ADD:   return "ADD";
       case ALLOC:   return "ALLOC";
       case BEQ:   return "BEQ";
       case BGE:   return "BGE";
       case BGT:   return "BGT";
       case BLE:   return "BLE";
       case BLT:   return "BLT";
       case BNE:   return "BNE";
       case DIV:   return "DIV";
       case HALT:   return "HALT";
       case JUMP:   return "JUMP";
       case LDA:   return "LDA";
       case MOD:   return "MOD";
       case MUL:   return "MUL";
       case NOT:   return "NOT";
       case PRINTI:   return "PRINTI";
       case PUSH:   return "PUSH";
       case SUB:   return "SUB";
       case VAL:   return "VAL";
     default: return "NO_OPCODE"; 
   
   }

}


void 
disassembler(machine m)
{
    return ;

//here
}

void
skipComment(srcBuffer *sb)
{
    if(peekChar(sb) == ';') advance(sb);
    else return;

    while(peekChar(sb) != '\n' || peekChar(sb) != '\0') advance(sb);


}



void 
resolveMnemonic(srcBuffer *sb , machine *m) 
{
    skipSpaces(sb);
    char *name;
    if (isalpha((unsigned char)peekChar(sb))) 
    {
        //get the menmonic name 
        int size = readMnemonic(sb, &name);
        if (size <= 0) return;
        char *pname = malloc(size + 1);
        if (!pname) {
            fprintf(stderr, "Out of memory\n");
            exit(1);
        }
        strncpy(pname, name, size);
        pname[size] = '\0'; //sentinel
        

        //get the opcode 
        opcode op = mnemonicToOpcode(pname);

        //insert into memory
        opcodeIntoMemory(m, op);
        
        //skip spaces 
        skipSpaces(sb);
        skipComment(sb);

        switch(op)
        {

            case PUSH:
            case ALLOC:
            case BEQ:
            case BNE:
            case BLE:
            case BLT:
            case BGE:
            case BGT:
                //get the operand
                if (isdigit((unsigned char)peekChar(sb)) || peekChar(sb) == '-') 
                {
                    int num = readInt(sb);
                    operandIntoMemory(m, num);
                }
                else 
                {
                    fprintf(stderr , "Expected a number at line: %d", sb->line);
                    exit(1);
                }
                break;
            default:
                break;

        }

        //resolve the mnemonic to opcode 
        free(pname);


    } else 
    {
        /* unknown char - skip single char to avoid infinite loop */
        printf("UNKNOWN CHAR '%c' at line %d\n", peekChar(sb), sb->line);
        advance(sb);
    }
}


unsigned int
assemble(char *filename, machine *m) 
{
    if (!filename) {
        fprintf(stderr, "Usage: assemble <sourcefile>\n");
        exit(1);
    }

    srcBuffer sb = {0};
    sb.buffer = NULL;
    sb.bufferSize = utility_fileReader(filename, &sb.buffer);
    sb.bufPointer = 0;
    sb.line = 1; /* 1-based line count */

    if (sb.bufferSize == 0 || sb.buffer == NULL) {
        fprintf(stderr, "Failed to read file '%s'\n", filename);
        exit(1);
    }



    while (sb.bufPointer < sb.bufferSize) {
        skipSpaces(&sb);
        skipComment(&sb);
        if (peekChar(&sb) == '\0') break;
        resolveMnemonic(&sb, m);
    }
    
    unsigned int size = m->ip;
    m->ip = 0;
    return size ;
}


